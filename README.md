# Software_eng_lab2

# کاربرد عملی اصول شئ‌گرایی SOLID با استفاده از روش Test Driven Development

---

## روال انجام آزمایش

این آزمایش برای یادگیری اصول SOLID و همچنین TDD بود. در آن باید با توجه به نکات مربوط به این دو مورد، پروژه‌ای به زبان جاوا پیاده‌سازی می‌کردیم. شرح مراحل پروژه و این آزمایش به شکل زیر است:

طبق خواسته‌ی آزمایش، در ابتدا باید پروژه‌ای به زبان Java می‌نوشتیم که با داشتن طول (height) و عرض (width) یک مستطیل (Rectangle)، مساحت آن را محاسبه کند. (متد computeArea) حال از آن‌جا که پیاده‌سازیمان باید با روش TDD باشد، در گام اول، انتظارات برنامه را به صورت تست (با استفاده از کتابخانه‌ی JUnit) می‌نویسیم:

<img title="" src="images/rec%20CA%201.png" alt="alt text" data-align="center" width="578">

در این تست، یک شئ مستطیل داریم که با متد `computeArea` باید بتوان مساحتش را به دست آورد. ورودی `delta` در `assertEquals`، برای این است که JUnit در رابطه با می‌دهیم.

بعد از build گرفتن، به خطای زیر می‌رسیم که به خاطر نداشتن کلاس مستطیل است. 

<img title="" src="images/rec%20CA%202.png" alt="alt text" data-align="center" width="597">

در این گام باید برویم و با اضافه کردن کد در برنامه، اشکالات کامپایلری تست‌ها را برطرف کنیم. از آن‌جا که می‌خواهیم اصول شئ‌گرایی SOLID را رعایت کنیم، از ابتدا، یک interface به عنوان shape می‌سازیم. با این کار اصول OCP و LSP را رعایت کرده‌ایم و در تغییرات آینده نیز به مشکل نخواهیم خورد. زیرا اگر بخواهیم شکل جدید اضافه کنیم، کافیست shape را implement کند و این‌گونه شکل‌های قبلی نیاز نیست تغییر کنند و OCP حفظ می‌‌شود و همچنین شکلی، فرزند شکل دیگری نخواهد شد و LSP حفظ می‌شود. فایل‌های `Shape.java` و `Rectangle.java` که اضافه می‌کنیم، به ترتیب به شکل زیر خواهند بود:

<img title="" src="images/rec%20CA%203-1.png" alt="alt text" data-align="center" width="582">

<img title="" src="images/rec%20CA%203-2.png" alt="alt text" data-align="center" width="592">

حال باید تست‌ را اجرا کنیم و ببینیم چه نتیجه‌ای می‌دهد: 

<img title="" src="images/rec%20CA%204.png" alt="loading-ag-532" data-align="center" width="596">

همان‌طور که می‌بینید تست‌ شکست خورد. حال باید با تغییر کد در برنامه، اشکالات زمان اجرای تست‌ را رفع کنیم. متد `computeArea` را به شکل زیر تغییر می‌دهیم:

<img title="" src="images/rec%20CA%205-1.png" alt="" data-align="center" width="521">

بعد از این تغییر، باز هم تست را اجرا می‌کنیم و حال می‌بینیم که موفق بود:

<img title="" src="images/rec%20CA%205-2.png" alt="" data-align="center" width="564">

حال طبق خواسته‌ی آزمایش، برنامه‌ی قبل را باید به گونه‌ای گسترش دهیم که امکان تغییر طول و عرض مستطیل وجود داشته باشد (متدهای `set` و `get`). بنابراین در گام اول تست‌های مورد نیاز را می‌نویسیم. البته ما در واقع ابتدا پروسه‌ی توابع `get` را طی کردیم و بعد `setها` را اضافه کردیم چرا که برای تست `set`، باید از کارکرد `getها` مطمئن می‌بودیم. اما در اینجا توضیحات و عکس‌ها را یک‌جا می‌آوریم:

<img title="" src="images/rec%20get%201.png" alt="" data-align="center" width="526">

<img title="" src="images/rec%20set%201.png" alt="" data-align="center" width="521">

حال build می‌گیریم و با خطاهای زیر روبرو می‌شویم:

<img title="" src="images/rec%20get%202.png" alt="" data-align="center" width="570">

<img title="" src="images/rec%20set%202.png" alt="" data-align="center" width="565">

حال در این گام باید با اضافه کردن کد در برنامه، اشکالات کامپایلری تست‌ها را برطرف کنیم. 

<img title="" src="images/rec%20get%203.png" alt="" data-align="center" width="437">

<img title="" src="images/rec%20set%203.png" alt="" data-align="center" width="467">

برای این توابع از آن‌جایی که صرفا `getter` و `setter` بودند، مرحله‌‌ای برای مشخص شدن اشکالات زمان اجرا و بعد برطرف کردن آن‌ها نداشتیم. تست‌ها موفق بودند:

<img title="" src="images/rec%20set%205.png" alt="" width="514" data-align="center">

تا این مرحله، پروژه‌ای داریم که با داشتن طول و عرض یک مستطیل، مساحت آن را محاسبه می‌کند و همچنین امکان تغییر طول و عرض مستطیل را دارد. حال طبق خواسته‌ی آزمایش، باید برنامه قبلی را به گونه‌ای گسترش دهیم که علاوه بر مستطیل، مربع را هم پوشش دهد. برای این کار، با نوشتن تست‌های مربوط به متد `computeArea`، متد `getSide` و متد `setSide` شروع می‌کنیم:

<img title="" src="images/sq%201.png" alt="" data-align="center" width="550">

سپس با build گرفتن، خطاها را شناسایی می‌کنیم:

<img title="" src="images/sq%202.png" alt="" data-align="center" width="514">

حال کد مربوط به کلاس `Square` را اضافه می‌کنیم:

<img title="" src="images/sq%203.png" alt="" width="521" data-align="center">

تست‌ها را اجرا می‌کنیم و می‌بینیم متد `computeArea` خطا دارد:

<img title="" src="images/sq%204.png" alt="" data-align="center" width="548">

حال باید کد را تغییر دهیم تا تست پاس شود. تغییر مورد نیاز و پاس شدن تست‌ها به ترتیب قابل مشاهده‌اند:

<img title="" src="images/sq%205-1.png" alt="" data-align="center" width="548">

<img title="" src="images/sq%205-2.png" alt="" data-align="center" width="574">

پروژه در این جا به پایان رسید چرا که تست‌های تمام نیازمندی‌های خواسته‌شده، موفقیت‌آمیز گذرانده شدند. حال این پروژه را از دید اصول SOLID بررسی می‌کنیم:

اصل SRP: کلاس‌های `Rectangle`، `Square` و `Shape` هر کدام یک مسئولیت واحد دارند: مستطیل مسئول محاسبه مساحت یک مستطیل است، مربع مسئول محاسبه مساحت یک مربع است، و شکل مسئول تعریف متد `computeArea` است که مساحت هر شکلی را محاسبه می‌کند.

اصل OCP: این پروژه برای توسعه باز و برای تغییر بسته است. `Shape` قراردادی را برای محاسبه مساحت یک شکل تعریف می‌کند و با implement این رابط و ارائه یک پیاده‌سازی خاص از متد `computeArea`، می‌توان اشکال جدیدی به پروژه اضافه کرد. کد موجود برای مستطیل و مربع برای افزودن اشکال جدید به پروژه نیازی به اصلاح ندارد.

اصل LSP: کلاس مربع LSP را نقض نمی‌کند، زیرا از کلاس مستطیل به ارث نمی‌برد. در عوض، `Shape` را پیاده‌سازی می‌کند و پیاده‌سازی خود را از متد `computeArea` ارائه می‌کند. 

اصل ISP: رابط `Shape` با تعریف یک متد `computeArea` که یک عملکرد خاص را ارائه می‌کند و کلاس‌هایی که implementاش می‌کنند را مجبور به ارائه روش‌های غیرضروری نمی‌کند، از ISP پیروی می‌کند. این مورد به کلاس‌هایی که `Shape` را پیاده‌سازی می‌کنند اجازه می‌دهد فقط از متدهایی که نیاز دارند استفاده کنند و مجبور به پیاده‌سازی متدهایی نباشند که به آن‌ها نیاز ندارند.

اصل DIP: این پروژه از DIP پیروی می‌کند و به انتزاعات بستگی دارد تا پیاده‌سازی عینی. کلاس‌های مستطیل و مربع به رابط شکل بستگی دارند، که یک انتزاع است که قراردادی را برای محاسبه مساحت یک شکل تعریف می‌کند که به ما اجازه می‌دهد تا پروژه منعطف و توسعه‌پذیرتر باشد، زیرا اشکال جدیدی که رابط شکل را implement می‌کنند، می توانند بدون تأثیر بر کد موجود به پروژه اضافه شوند.

---

## پرسش‌ها

1. هر یک از پنج اصل SOLID را در دو الی سه خط توضیح دهید.

اصل SRP: یک کلاس باید تنها یک دلیل برای تغییر داشته باشد، به این معنی که باید فقط یک مسئولیت یا کار برای انجام دادن داشته باشد. این اصل به متمرکز بودن و نگهداری کلاس‌ها کمک می‌کند.

اصل OCP: یک کلاس باید برای توسعه باز باشد اما برای تغییر بسته باشد. یعنی که عملکردهای جدید باید از طریق کد جدید اضافه شوند نه با تغییر کد موجود، که به جلوگیری از عوارض جانبی ناخواسته کمک می‌کند و کد را انعطاف‌پذیرتر می‌کند.

اصل LSP: انواع زیرین باید بتوانند برای انواع پایه‌ی خود جایگزین شوند. یعنی این که هر نمونه از یک کلاس مشتق‌شده باید بتواند به جای نمونه‌ای از کلاس پایه‌اش بدون تأثیر بر صحت برنامه استفاده شود. این اصل کمک می‌کند تا اطمینان حاصل شود که رفتار برنامه در تمام نمونه‌های یک نوع معین با هم سازگارند.

اصل ISP: کلاینت‌ها نباید مجبور شوند به واسط‌هایی که استفاده نمی‌کنند وابسته باشند. این بدان معنی است که رابط‌ها باید به گونه‌ای طراحی شوند که منسجم (cohesive) و متمرکز بر مجموعه خاصی از رفتارهای مرتبط باشند، نه اینکه متدهای نامرتبط یا غیر ضروری را شامل شوند. این اصل کمک می کند تا رابط ها کوچک و قابل نگهداری باشند.

اصل DIP: ماژول‌های سطح بالا نباید به ماژول‌های سطح پایین وابسته باشند. هر دو باید به انتزاعات بستگی داشته باشند. این بدان معنی است که جزئیات پیاده‌سازی باید از منطق سطح بالای برنامه جدا شود و از انتزاعات برای تعریف وابستگی بین مؤلفه‌ها استفاده شود. این اصل به جداسازی مولفه‌ها و انعطاف‌پذیرتر و قابل‌ نگهداری‌تر شدن کد کمک می‌کند.

---

2. اصول SOLID در کدام یک از گام‌های اصلی ایجاد نرم‌افزار (تحلیل نیازمندی‌ها، طراحی، پیاده‌سازی، تست و استقرار) استفاده می‌شوند؟ توضیح دهید.

اصول SOLID عمدتا در مراحل طراحی و پیاده‌سازی ایجاد نرم افزار استفاده می‌شوند.

در طول مرحله طراحی، اصول SOLID می‌توانند برای هدایت ایجاد یک معماری نرم‌افزاری modular، قابل نگهداری و انعطاف‌پذیر استفاده شود. این بخش شامل شناسایی اجزای کلیدی سیستم و تعریف روابط بین آن‌ها، با استفاده از اصول SOLID برای اطمینان از اینکه هر جزء دارای مسئولیتی روشن است و اینکه وابستگی بین اجزا به خوبی تعریف شده است، می‌باشد.

در طول مرحله پیاده‌سازی، اصول SOLID را می‌توان برای هدایت ایجاد کلاس‌ها و توابع مجزا مورد استفاده قرار داد، و اطمینان حاصل کرد که آنها متمرکز، منسجم و آسان برای تست شدن هستند. این بخش شامل استفاده از اصول SOLID برای شناسایی و حذف code smellها، مانند تکرار و coupling، و ایجاد کدی است که به راحتی قابل گسترش و نگهداری باشد.

---

3. در چرخه‌ی عمومی ایجاد نرم‌افزار، آزمون نرم‌افزار دیرتر از پیاده‌سازی نرم‌افزار انجام می‌شود، اما در روش TDD تست‌نویسی پیش از پیاده‌سازی شروع می‌شود. آیا این دو مورد با هم تناقضی دارند؟ توضیح دهید.

خیر، متناقض نیستند، بلکه بیانگر شیوه های متفاوتی از پیاده‌سازی و توسعه نرم‌افزار هستند.

در چرخه عمومی توسعه نرم‌افزار، آزمون معمولاً پس از پیاده‌سازی به عنوان بخشی از یک مرحله‌ی آزمون جداگانه انجام می‌شود. این رویکرد شامل نوشتن کل برنامه قبل از انجام هر آزمونی است. در حالی که این رویکرد می‌تواند در برخی موارد موثر باشد، اما اگر نقص‌ها در اواخر فرآیند توسعه کشف شوند، می‌تواند منجر به تاخیر و دوباره‌کاری پرهزینه شود.

از سوی دیگر، رویکرد TDD شامل نوشتن تست‌ها قبل از اجرای کد است. در این رویکرد، از تست‌ها برای هدایت فرآیند توسعه استفاده می‌شود، که هر تست یک نیازمندی یا ویژگی خاصی را تعریف می‌کند که کد باید آن را برآورده کند. سپس کد به صورت تدریجی برای گذراندن تست‌ها نوشته می‌شود و آزمون‌ها به طور مکرر اجرا می‌شوند تا از صحت کد و مطابقت با نیازمندی‌ها اطمینان حاصل شود.

در حالی که این دو رویکرد ممکن است در ابتدا متناقض به نظر برسند، اما در واقع مکمل یکدیگر هستند. TDD را می‌توان به عنوان راهی با شناسایی نقص‌ها در اوایل چرخه توسعه و کاهش نیاز به مراحل آزمون جداگانه در نظر گرفت. با استفاده از تست‌ها برای هدایت فرآیند توسعه، TDD می‌تواند با تشویق توسعه‌دهندگان به نوشتن کدی که modular، قابل آزمایش و متمرکز بر الزامات خاص باشد، به بهبود طراحی و قابلیت نگهداری کد کمک کند. بنابراین تفاوت بین چرخه عمومی توسعه نرم‌افزار و TDD یک تناقض نیست، بلکه یک تفاوت در رویکرد است. هر دو رویکرد مزایا و معایب خود را دارند و انتخاب رویکرد به الزامات و محدودیت‌های خاص پروژه بستگی دارد.

---

4. فرض کنید در آزمایش بالا نیازی به تغییر ابعاد مستطیل نداشتیم. آیا در این حالت می‌توانستیم مربع را از مستطیل به ارث ببریم؟ توضیح دهید.

بله، در صورتی که ابعاد مربع و مستطیل قابل تغییر نباشد، می‌توان کلاس `Square` را از کلاس `Rectangle` به ارث برد.

از آنجایی که مربع حالت خاصی از یک مستطیل است که در آن هر چهار ضلع با هم برابر باشند، کلاس مربع را می توان از کلاس مستطیل با اعمال محدودیتی که عرض و ارتفاع یک شئ مربع باید همیشه برابر باشد، استخراج کرد. این کار را می‌توان با افزودن یک `constructor` به کلاس مربع که یک آرگومان واحد برای طول ضلع می‌گیرد، و ارسال این آرگومان به `constructor` مستطیل برای عرض و طول انجام داد.

نمونه ای از این پیاده‌سازی که کلاس `Square` از کلاس `Rectangle` به ارث می‌برد، به شکل زیر خواهد بود:

```java
public class Square extends Rectangle {
    public Square(double side) {
        super(side, side);
    }
}
```

در این پیاده سازی، کلاس مربع `constructorای` دارد که یک آرگومان واحد برای طول ضلع می‌گیرد و آن را با همان مقدار برای عرض و طول به `constructor` کلاس مستطیل ارسال می‌کند. از آنجایی که کلاس مربع تمام متدها و ویژگی‌های کلاس مستطیل را به ارث می‌برد، می‌توان آن را به همان روش مستطیل استفاده کرد، اما با این محدودیت که عرض و ارتفاع همیشه باید برابر باشند.

---
