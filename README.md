# Software_eng_lab2

# کاربرد عملی اصول شئ‌گرایی SOLID با استفاده از روش Test Driven Development

---

## روال انجام آزمایش

این آزمایش برای یادگیری اصول SOLID و همچنین TDD بود. در آن باید با توجه به نکات مربوط به این دو مورد، پروژه‌ای به زبان جاوا پیاده‌سازی می‌کردیم. شرح مراحل پروژه و این آزمایش به شکل زیر است:

طبق خواسته‌ی آزمایش، در ابتدا باید پروژه‌ای به زبان Java می‌نوشتیم که با داشتن طول (height) و عرض (width) یک مستطیل (Rectangle)، مساحت آن را محاسبه کند. (متد computeArea) حال از آن‌جا که پیاده‌سازیمان باید با روش TDD باشد، در گام اول، انتظارات برنامه را به صورت تست (با استفاده از کتابخانه‌ی JUnit) می‌نویسیم:

<img title="" src="images/rec%20CA%201.png" alt="alt text" data-align="center" width="578">

در این تست، یک شئ مستطیل داریم که با متد `computeArea` باید بتوان مساحتش را به دست آورد. ورودی `delta` در `assertEquals`، برای این است که JUnit در رابطه با می‌دهیم.

بعد از build گرفتن، به خطای زیر می‌رسیم که به خاطر نداشتن کلاس مستطیل است. 

<img title="" src="images/rec%20CA%202.png" alt="alt text" data-align="center" width="597">

در این گام باید برویم و با اضافه کردن کد در برنامه، اشکالات کامپایلری تست‌ها را برطرف کنیم. از آن‌جا که می‌خواهیم اصول شئ‌گرایی SOLID را رعایت کنیم، از ابتدا، یک interface به عنوان shape می‌سازیم. با این کار اصول OCP و LSP را رعایت کرده‌ایم و در تغییرات آینده نیز به مشکل نخواهیم خورد. زیرا اگر بخواهیم شکل جدید اضافه کنیم، کافیست shape را implement کند و این‌گونه شکل‌های قبلی نیاز نیست تغییر کنند و OCP حفظ می‌‌شود و همچنین شکلی، فرزند شکل دیگری نخواهد شد و LSP حفظ می‌شود. فایل‌های Shape.java و Rectangle.java که اضافه می‌کنیم، به ترتیب به شکل زیر خواهند بود:

<img title="" src="images/rec%20CA%203-1.png" alt="alt text" data-align="center" width="582">

<img title="" src="images/rec%20CA%203-2.png" alt="alt text" data-align="center" width="592">

حال باید تست‌ را اجرا کنیم و ببینیم چه نتیجه‌ای می‌دهد: 

<img title="" src="images/rec%20CA%204.png" alt="loading-ag-532" data-align="center" width="596">

همان‌طور که می‌بینید تست‌ شکست خورد. حال باید با تغییر کد در برنامه، اشکالات زمان اجرای تست‌ را رفع کنیم. متد computeArea را به شکل زیر تغییر می‌دهیم:

<img title="" src="images/rec%20CA%205-1.png" alt="" data-align="center" width="521">

بعد از این تغییر، باز هم تست را اجرا می‌کنیم و حال می‌بینیم که موفق بود:

<img title="" src="images/rec%20CA%205-2.png" alt="" data-align="center" width="564">

حال طبق خواسته‌ی آزمایش، برنامه‌ی قبل را باید به گونه‌ای گسترش دهیم که امکان تغییر طول و عرض مستطیل وجود داشته باشد (متدهای set و get). بنابراین در گام اول تست‌های مورد نیاز را می‌نویسیم. البته ما در واقع ابتدا پروسه‌ی توابع get را طی کردیم و بعد setها را اضافه کردیم چرا که برای تست set، باید از کارکرد getها مطمئن می‌بودیم. اما در اینجا توضیحات و عکس‌ها را یک‌جا می‌آوریم:

<img title="" src="images/rec%20get%201.png" alt="" data-align="center" width="526">

<img title="" src="images/rec%20set%201.png" alt="" data-align="center" width="521">

حال build می‌گیریم و با خطاهای زیر روبرو می‌شویم:

<img title="" src="images/rec%20get%202.png" alt="" data-align="center" width="570">

<img title="" src="images/rec%20set%202.png" alt="" data-align="center" width="565">

حال در این گام باید با اضافه کردن کد در برنامه، اشکالات کامپایلری تست‌ها را برطرف کنیم. 

<img title="" src="images/rec%20get%203.png" alt="" data-align="center" width="437">

<img title="" src="images/rec%20set%203.png" alt="" data-align="center" width="467">

برای این توابع از آن‌جایی که صرفا getter و setter بودند، مرحله‌‌ای برای مشخص شدن اشکالات زمان اجرا و بعد برطرف کردن آن‌ها نداشتیم. تست‌ها موفق بودند:

<img title="" src="images/rec%20set%205.png" alt="" width="514" data-align="center">

تا این مرحله، پروژه‌ای داریم که با داشتن طول و عرض یک مستطیل، مساحت آن را محاسبه می‌کند و همچنین امکان تغییر طول و عرض مستطیل را دارد. حال طبق خواسته‌ی آزمایش، باید برنامه قبلی را به گونه‌ای گسترش دهیم که علاوه بر مستطیل، مربع را هم پوشش دهد. برای این کار، با نوشتن تست‌های مربوط به متد computeArea، متد getSide و متد setSide شروع می‌کنیم:

<img title="" src="images/sq%201.png" alt="" data-align="center" width="550">

سپس با build گرفتن، خطاها را شناسایی می‌کنیم:

<img title="" src="images/sq%202.png" alt="" data-align="center" width="514">

حال کد مربوط به کلاس Square را اضافه می‌کنیم:

<img title="" src="images/sq%203.png" alt="" width="521" data-align="center">

تست‌ها را اجرا می‌کنیم و می‌بینیم متد computeArea خطا دارد:

<img title="" src="images/sq%204.png" alt="" data-align="center" width="548">

حال باید کد را تغییر دهیم تا تست پاس شود. تغییر مورد نیاز و پاس شدن تست‌ها به ترتیب قابل مشاهده‌اند:

<img title="" src="images/sq%205-1.png" alt="" data-align="center" width="548">

<img title="" src="images/sq%205-2.png" alt="" data-align="center" width="574">

پروژه در این جا به پایان رسید چرا که تست‌های تمام نیازمندی‌های خواسته‌شده، موفقیت‌آمیز گذرانده شدند. حال این پروژه را از دید اصول SOLID بررسی می‌کنیم:

اصل SRP: کلاس‌های Rectangle، Square و Shape هر کدام یک مسئولیت واحد دارند: مستطیل مسئول محاسبه مساحت یک مستطیل است، مربع مسئول محاسبه مساحت یک مربع است، و شکل مسئول تعریف متد `computeArea` است که مساحت هر شکلی را محاسبه می‌کند.

اصل OCP: این پروژه برای توسعه باز و برای تغییر بسته است. Shape قراردادی را برای محاسبه مساحت یک شکل تعریف می‌کند و با implement این رابط و ارائه یک پیاده‌سازی خاص از متد computeArea، می‌توان اشکال جدیدی به پروژه اضافه کرد. کد موجود برای مستطیل و مربع برای افزودن اشکال جدید به پروژه نیازی به اصلاح ندارد.

اصل LSP: کلاس مربع LSP را نقض نمی‌کند، زیرا از کلاس مستطیل به ارث نمی‌برد. در عوض، Shape را پیاده‌سازی می‌کند و پیاده‌سازی خود را از متد computeArea ارائه می‌کند. 

اصل ISP: رابط Shape با تعریف یک متد computeArea که یک عملکرد خاص را ارائه می‌کند و کلاس‌هایی که implementاش می‌کنند را مجبور به ارائه روش‌های غیرضروری نمی‌کند، از ISP پیروی می‌کند. این مورد به کلاس‌هایی که Shape را پیاده‌سازی می‌کنند اجازه می‌دهد فقط از متدهایی که نیاز دارند استفاده کنند و مجبور به پیاده‌سازی متدهایی نباشند که به آن‌ها نیاز ندارند.

اصل DIP: این پروژه از DIP پیروی می‌کند و به انتزاعات بستگی دارد تا پیاده‌سازی عینی. کلاس‌های مستطیل و مربع به رابط شکل بستگی دارند، که یک انتزاع است که قراردادی را برای محاسبه مساحت یک شکل تعریف می‌کند که به ما اجازه می‌دهد تا پروژه منعطف و توسعه‌پذیرتر باشد، زیرا اشکال جدیدی که رابط شکل را implement می‌کنند، می توانند بدون تأثیر بر کد موجود به پروژه اضافه شوند.

---

## پرسش‌ها

1.  هر یک از پنج اصل SOLID را در دو الی سه خط توضیح دهید.



---

2. اصول SOLID در کدام یک از گام‌های اصلی ایجاد نرم‌افزار (تحلیل نیازمندی‌ها، طراحی، پیاده‌سازی، تست و استقرار) استفاده می‌شوند؟ توضیح دهید.



---

3. در چرخه‌ی عمومی ایجاد نرم‌افزار، آزمون نرم‌افزار دیرتر از پیاده‌سازی نرم‌افزار انجام می‌شود، اما در روش TDD تست‌نویسی پیش از پیاده‌سازی شروع می‌شود. آیا این دو مورد با هم تناقضی دارند؟ توضیح دهید.



---

4. فرض کنید در آزمایش بالا نیازی به تغییر ابعاد مستطیل نداشتیم. آیا در این حالت می‌توانستیم مربع را از مستطیل به ارث ببریم؟ توضیح دهید.



---
